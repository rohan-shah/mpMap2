% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/addExtraMarkers.R
\name{addExtraMarkers}
\alias{addExtraMarkers}
\title{Add extra markers}
\usage{
addExtraMarkers(mpcrossMapped, newMarkers,
  useOnlyExtraImputationPoints = TRUE, reorderRadius = 103,
  maxOffset = 50, knownChromosome, imputationArgs = NULL,
  onlyStatistics = FALSE, orderCrossArgs = list(),
  attemptMpMap2Interactive = TRUE, verbose = TRUE, reorder = TRUE)
}
\arguments{
\item{mpcrossMapped}{An existing dataset with a map, which must include imputation data and recombination fraction data.}

\item{newMarkers}{A data object containing the new markers to add}

\item{useOnlyExtraImputationPoints}{Use only the additional points at which imputation data has been generated? Currently this must be \code{TRUE}.}

\item{reorderRadius}{The width of the region in which to attempt to reorder, after the extra markers are added, in terms of number of markers.}

\item{maxOffset}{The maxOffset parameter for the call to \code{\link{estimateMap}}, which is used to re-estimate the map (locally), after the additional markers are added.}

\item{knownChromosome}{The name of a chromosome, if the extra markers are known to go on a specific chromosome}

\item{imputationArgs}{A list containing additional arguments to \code{\link{imputeFounders}}.}

\item{onlyStatistics}{If this argument is \code{TRUE}, then only the chi-squared test statistic values are computed, and the markers are not added.}

\item{orderCrossArgs}{A list containing additional arguments to \code{\link{orderCross}}.}

\item{attemptMpMap2Interactive}{If local reordering is to be performed after the extra markers are added, should this be done interactively, using package mpMapInteractive2?}

\item{verbose}{Should extra logging output be generated?}

\item{reorder}{Should local reordering be performed after the extra markers are added?}
}
\value{
A list with an entry named \code{statistics}, containing the test statistic values. If \code{onlyStatistics} was set to \code{FALSE}, then the list also contains an entry named \code{object}, containing the input object and the extra markers.
}
\description{
Add extra markers to a map, using a QTL-mapping style approach.
}
\details{
This function uses a QTL-mapping style approach to add extra markers to an existing map. The code uses the imputation data at a collection of points, and the marker alleles for the \emph{first} marker of the extra markers. If the imputed genotype at a point is independent from the marker allele, then that marker probably should not be mapped to that point. If the imputed genotype at a point and the marker allele are strongly dependent, then the marker should probably be mapped to that point. Dependence and independence are measured using a chi-squared test stastistic for independence. \emph{All the extra markers} are then mapped to the position where the test statistic is largest. 

Currently the set of points which are tested is the set of points at which imputation data is available, \emph{which are not markers}. The intention is that this set of points should be an equally spaced grid of points; this has the affect of radically reducing the number of tests that are performed, as generally there are far fewer points in this grid, than there are markers. As the position chosen will need to be inspected and changed manually in any case, any loss in accuracy by using the grid of point is essentially irrelevant. In future it may be possible to use every marker position as the set of points at which tests are performed, by setting \code{useOnlyExtraImputationPoints} to \code{FALSE}. 

Once the extra markers have added, local reordering is optionally performed, depending on argument \code{reordering}. The radius of the region on which reordering is performed, in terms of the number of markers, is \code{reorderRadius}. If \code{attemptMpMap2Interactive} is \code{TRUE}, then package mpMapInteractive2 will be used to reorder the markers; this requires the user to perform reordering interactively. Otherwise, function \code{orderCross} will be used to automatically perform reordering. 

Once the optional reordering step has been performed, the map is recomputed locally, to account for the addition of the extra marker. The argument \code{maxOffset} is passed through to \code{estimateMap}. Finally, the imputation data will be recomputed if \code{imputationArgs} is not \code{NULL}; in that case, \code{imputationArgs} should contain a list of arguments to \code{imputeFounders}. It is recommended that the imputation data be recomputed if further markers are to be added. 

If a threshold is to be applied to the maximum value of the test statistics, this function should be called twice. For the first call, \code{onlyStatistics} should be set to \code{FALSE}. If the resulting test statistics exceed the threshold, then \code{addExtrMarkers} should be called again with \code{onlyStatistics} set to \code{TRUE}. It is recommended that only single markers be added at a time, unless you are extremely confident that all the extra markers should be located at the same position.
}
\examples{
#construct four-parent pedigree
pedigree <- fourParentPedigreeRandomFunnels(initialPopulationSize = 1000, 
	selfingGenerations = 6, intercrossingGenerations = 0)
#Assume infinite generations of selfing in subsequent analysis
selfing(pedigree) <- "infinite"
#Generate random map
map <- qtl::sim.map(len = 100, n.mar = 101, anchor.tel = TRUE, include.x = FALSE)
#Simulate data
cross <- simulateMPCross(map = map, pedigree = pedigree, mapFunction = haldane, seed = 1L)
#Create object that includes the correct map
mapped <- new("mpcrossMapped", cross, map = map)
#Remove marker number 50. Normally the map is discarded, but we specify to keep it. 
removedMiddle <- subset(mapped, markers = (1:101)[-50], keepMap = TRUE)
#Compute imputation data, at all the markers, and an equally spaced grid of points
removedMiddle <- imputeFounders(removedMiddle, errorProb = 0.02, 
	extraPositions = generateGridPositions(1))
#Estimate recombination fractions
removedMiddle <- estimateRF(removedMiddle)
#Get out the extra marker to add
extraMarker <- subset(cross, markers = 50)
#Add the extra marker, without doing any local reordering. After the marker is added, 
#	recompute the imputation data, using the same arguments as previously. 
withExtra <- addExtraMarkers(mpcrossMapped = removedMiddle, newMarkers = extraMarker, 
	reorder = FALSE, imputationArgs = list(errorProb = 0.02, 
	extraPositions = generateGridPositions(1)))$object
}

